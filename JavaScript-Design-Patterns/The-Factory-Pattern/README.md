工厂模式：<br />
1.1、简单工厂：<br />
另外使用一个类（通常是一个单例）来生成实例，示例程序；<br />
1.2、工厂模式：<br />
使用子类来决定一个成员变量应该是哪个具体的类的实例，示例程序；<br />
1.3、工厂模式的适用场景：<br />
1.3.1、动态实现：<br />
XHR的例子，使用简单工厂，注意在工厂方法中使用到的memoizing技术；<br />
专用型连接对象：创建两个新的处理器类：<br />
QueuedHandler：在发起新的请求之前先确保所有请求都已经成功处理。<br />
OfflineHandler：在用户处于离线状态时把请求缓存起来。<br />
示例程序<br />
在运行时选择连接对象：示例程序<br />
1.3.2、节省设置开销：<br />
把设置代码放到类的构造函数中并不是一种高效的做法，这是因为即便设置工作已经完成，每次创建新实例的时候这些代码还是会执行，而且这样做会把设置代码分散到不同的类中。工厂方法非常适合于这种场合。它可以再实例化所有需要的对象之前一次性地进行设置。<br />
1.3.3、用许多小型对象组成一个大对象：<br />
RSS阅读器：由ListDisplay, XhrHandler, conf对象组成，包括fetchFeed, parseFeed, showError, stopUpdates, startUpdates方法。这是一个阐明“用许多小型对象组成一个大对象”这个用途的绝佳示例。它使用工厂模式，先创建出所有要用到的对象，然后再生成并返回那个作为容器的FeedReader类型大对象：示例程序<br />
1.4、优点：<br />
弱化对象的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。这是在用一个对接口的调用取代具体的实现。这些都有助于创建模块化的代码。使用工厂模式，你可以先创建一个抽象的父类，然后再子类中创建工厂方法，从而把成员对象的实例化推迟到更专门化的子类中进行。<br />
通过使用工厂方法而不是new关键字及具体类，你可以把所有实例化代码集中在一个位置，可以大大简化更换所用的类或在运行期间动态选择所用的类的工作。<br />
1.5、缺点：<br />
如果不需要再运行期间在一系列可互换的类中进行选择，那就不应该使用工厂方法。大多数类最好使用new关键字和构造函数公开初始化，使代码更简单易读，一眼就看到调用的是什么构造函数而不用查看工厂方法。<br />
如果拿不定主意，就不要用工厂模式，因为在代码重构时还有机会使用工厂模式。